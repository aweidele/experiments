<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Plain JS Carousel (N + 0.5)</title>
    <style>
      :root {
        --gap: 50px;
      }

      ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }

      /* Constrained wrapper */
      .carousel {
        max-width: 1100px; /* your “constrained area” */
        margin: 2rem auto;
        overflow: visible; /* requirement: next/prev partial slide visible outside track */
        position: relative;
        font-family: system-ui, sans-serif;
      }

      /* Buttons */
      .carousel__controls {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        margin-block: 0.75rem;
      }
      .carousel__button {
        padding: 0.5rem 0.75rem;
        border: 1px solid #ccc;
        background: #fff;
        border-radius: 0.5rem;
        cursor: pointer;
      }
      .carousel__button[disabled] {
        opacity: 0.5;
        cursor: not-allowed;
      }

      /* Viewport + track */
      .carousel__viewport {
        outline: none; /* we’ll show focus style on wrapper below */
        overflow: visible; /* requirement */
        position: relative;
        background-color: #ddd;
      }
      .carousel:focus-within {
        /* box-shadow: 0 0 0 3px #bde;
        border-radius: 0.5rem; */
      }

      .carousel__track {
        display: flex;
        gap: var(--gap);
        will-change: transform;
        transition: transform 400ms ease;
        /* Allow vertical page scroll while we handle horizontal swipes with Pointer Events */
        touch-action: pan-y;
      }

      /* Slides */
      .carousel__slide {
        flex: 0 0 auto; /* width is set via JS for exact math */
        border-radius: 0.75rem;
        border: 1px solid #e5e5e5;
        background: #fafafa;
        padding: 1rem;
        box-sizing: border-box;
        /* Make each slide programmatically focusable for arrow-key behavior */
        outline: none;
      }
      .carousel__slide:focus {
        box-shadow: 0 0 0 3px #ace;
      }

      /* Dots */
      .carousel__dots {
        display: flex;
        gap: 0.5rem;
        align-items: center;
        flex-wrap: wrap;
      }
      .carousel__dot {
        width: 0.75rem;
        height: 0.75rem;
        border-radius: 50%;
        border: 1px solid #888;
        background: #ddd;
        cursor: pointer;
        display: inline-block;
      }
      .carousel__dot[aria-current="true"] {
        background: #333;
        border-color: #333;
      }

      /* Visually hidden (for screen-reader only text) */
      .sr-only {
        position: absolute !important;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
    </style>
  </head>
  <body>
    <!--
  Config:
   data-visible-base="2"  -> shows 2.5 slides (N + 0.5)
   data-advance-by="2"    -> next/prev step size in slides
   data-gap="50"          -> pixels between slides
-->
    <div class="carousel" id="exampleCarousel" data-visible-base="2" data-advance-by="2" data-gap="50" aria-label="Featured projects carousel">
      <div class="carousel__viewport" tabindex="0" role="region" aria-roledescription="carousel" aria-label="Carousel viewport">
        <ul class="carousel__track" aria-live="polite">
          <!-- Demo content; add as many slides as you like -->
          <li class="carousel__slide" tabindex="-1" aria-label="Slide 1">
            <h3>Slide 1</h3>
            <p>Any HTML content goes here.</p>
          </li>
          <li class="carousel__slide" tabindex="-1" aria-label="Slide 2">
            <h3>Slide 2</h3>
            <p>Gaps are consistent and configurable.</p>
          </li>
          <li class="carousel__slide" tabindex="-1" aria-label="Slide 3">
            <h3>Slide 3</h3>
            <p>Shows N + 0.5 slides in view.</p>
          </li>
          <li class="carousel__slide" tabindex="-1" aria-label="Slide 4">
            <h3>Slide 4</h3>
            <p>Next/Prev + dots + keys + wheel + swipe.</p>
          </li>
          <li class="carousel__slide" tabindex="-1" aria-label="Slide 5">
            <h3>Slide 5</h3>
            <p>Right edge can align perfectly.</p>
          </li>
          <li class="carousel__slide" tabindex="-1" aria-label="Slide 6">
            <h3>Slide 6</h3>
            <p>Fully responsive, recalculates on resize.</p>
          </li>
        </ul>
      </div>

      <div class="carousel__controls" aria-label="Carousel controls">
        <button type="button" class="carousel__button carousel__prev" aria-label="Previous slides">◀ Prev</button>
        <button type="button" class="carousel__button carousel__next" aria-label="Next slides">Next ▶</button>
      </div>

      <div class="carousel__dots" aria-label="Slide navigation"></div>
      <p class="sr-only" id="carousel-status" aria-live="polite"></p>
    </div>

    <script>
      (() => {
        class NPlusHalfCarousel {
          constructor(root) {
            this.root = root;
            this.viewport = root.querySelector(".carousel__viewport");
            this.track = root.querySelector(".carousel__track");
            this.slides = Array.from(root.querySelectorAll(".carousel__slide"));
            this.prevBtn = root.querySelector(".carousel__prev");
            this.nextBtn = root.querySelector(".carousel__next");
            this.dotsWrap = root.querySelector(".carousel__dots");
            this.status = root.querySelector("#carousel-status");

            // Config (data-* attributes)
            this.baseVisible = Number(root.dataset.visibleBase || 2); // N (so we show N + 0.5)
            this.advanceBy = Number(root.dataset.advanceBy || this.baseVisible);
            this.gap = Number(root.dataset.gap || 50);

            // Internal state
            this.slideW = 0;
            this.stepPx = 0;
            this.maxScroll = 0;
            this.pagePositions = [];
            this.scrollX = 0;
            this.drag = { active: false, startX: 0, lastX: 0, scrolled: 0 };

            // Apply gap to CSS variable
            this.root.style.setProperty("--gap", this.gap + "px");

            this.init();
          }

          init() {
            this.buildDots();
            this.bindEvents();
            this.measureAndLayout();
            this.gotoPage(0, false);
            this.announce(); // initial
          }

          /* Layout math:
       We want N + 0.5 slides in view with N gaps (because the partial slide sits after an extra gap),
       so: container = N*w + 0.5*w + N*gap  =>  w = (container - N*gap) / (N + 0.5)
    */
          measureAndLayout() {
            const containerW = this.viewport.clientWidth;
            this.slideW = (containerW - this.baseVisible * this.gap) / (this.baseVisible + 0.5);

            // Set exact width on each slide (prevents rounding drift)
            this.slides.forEach((el) => {
              el.style.width = `${this.slideW}px`;
            });

            // Track total width for clamping
            const trackW = this.slides.length * this.slideW + (this.slides.length - 1) * this.gap;
            this.maxScroll = Math.max(0, trackW - containerW);

            // How far is one "page" advance?
            this.stepPx = this.advanceBy * (this.slideW + this.gap);

            // Precompute page positions (0 → … → maxScroll)
            const pages = [];
            let pos = 0;
            while (pos < this.maxScroll) {
              pages.push(pos);
              pos += this.stepPx;
            }
            pages.push(this.maxScroll);
            this.pagePositions = pages;

            // Rebuild dots if page count changed
            if (this.dotsWrap.childElementCount !== this.pagePositions.length) {
              this.buildDots();
            }

            // Snap existing scroll to closest valid page after resize
            this.scrollX = this.clamp(this.scrollX, 0, this.maxScroll);
            const nearest = this.nearestPageIndex(this.scrollX);
            this.setTransform(this.pagePositions[nearest], false);
            this.updateUI(nearest);
          }

          buildDots() {
            this.dotsWrap.innerHTML = "";
            this.pagePositions.forEach((_, i) => {
              const b = document.createElement("button");
              b.type = "button";
              b.className = "carousel__dot";
              b.setAttribute("aria-label", `Go to page ${i + 1}`);
              b.addEventListener("click", () => this.gotoPage(i));
              this.dotsWrap.appendChild(b);
            });
          }

          bindEvents() {
            // Buttons
            this.prevBtn.addEventListener("click", () => this.prev());
            this.nextBtn.addEventListener("click", () => this.next());

            // Keyboard (arrow keys move one slide at a time)
            this.viewport.addEventListener("keydown", (e) => {
              if (e.key === "ArrowRight") {
                e.preventDefault();
                this.bySlides(1);
              } else if (e.key === "ArrowLeft") {
                e.preventDefault();
                this.bySlides(-1);
              } else if (e.key === "Home") {
                e.preventDefault();
                this.gotoPage(0);
              } else if (e.key === "End") {
                e.preventDefault();
                this.gotoPage(this.pagePositions.length - 1);
              }
              // Do NOT trap Tab; let it move to next focusable content naturally
            });

            // Mousewheel / trackpad (advance per step)
            this.viewport.addEventListener(
              "wheel",
              (e) => {
                // Horizontal intent: deltaX or Shift+vertical
                const intent = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? e.deltaX : e.shiftKey ? e.deltaY : 0;
                if (!intent) return;
                e.preventDefault(); // we're animating ourselves
                if (intent > 0) this.next();
                else this.prev();
              },
              { passive: false }
            );

            // Pointer swipe (works for touch + mouse)
            this.viewport.addEventListener("pointerdown", (e) => this.onPointerDown(e));
            window.addEventListener("pointermove", (e) => this.onPointerMove(e));
            window.addEventListener("pointerup", (e) => this.onPointerUp(e));
            window.addEventListener("pointercancel", (e) => this.onPointerUp(e));

            // Resize
            const ro = new ResizeObserver(() => this.measureAndLayout());
            ro.observe(this.viewport);
            this._ro = ro;

            // Reduce motion: remove transition if user prefers
            if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
              this.track.style.transition = "none";
            }
          }

          onPointerDown(e) {
            if (e.button !== 0 && e.pointerType === "mouse") return;
            this.drag.active = true;
            this.drag.startX = e.clientX;
            this.drag.lastX = e.clientX;
            this.drag.scrolled = 0;
            this.track.style.transition = "none"; // free-drag feel
            this.viewport.setPointerCapture?.(e.pointerId);
          }
          onPointerMove(e) {
            if (!this.drag.active) return;
            const dx = e.clientX - this.drag.lastX;
            this.drag.lastX = e.clientX;
            this.drag.scrolled -= dx; // invert (drag left → move content left)
            const target = this.clamp(this.scrollX + this.drag.scrolled, 0, this.maxScroll);
            this.setTransform(target, false);
          }
          onPointerUp(e) {
            if (!this.drag.active) return;
            // Decide if swipe passed threshold → step
            const totalDx = e.clientX - this.drag.startX;
            this.track.style.transition = ""; // restore smoothness
            if (Math.abs(totalDx) > Math.max(40, this.slideW * 0.15)) {
              if (totalDx < 0) this.next();
              else this.prev();
            } else {
              // snap back to nearest
              const nearest = this.nearestPageIndex(this.scrollX + this.drag.scrolled);
              this.gotoPage(nearest);
            }
            this.drag.active = false;
            this.drag.scrolled = 0;
          }

          bySlides(n) {
            const px = n * (this.slideW + this.gap);
            const target = this.clamp(this.scrollX + px, 0, this.maxScroll);
            this.setTransform(target, true);
            this.afterMove();
          }

          prev() {
            const i = this.nearestPageIndex(this.scrollX);
            const targetIndex = Math.max(0, i - 1);
            this.gotoPage(targetIndex);
          }

          next() {
            const i = this.nearestPageIndex(this.scrollX);
            const targetIndex = Math.min(this.pagePositions.length - 1, i + 1);
            this.gotoPage(targetIndex);
          }

          gotoPage(i, animate = true) {
            const x = this.pagePositions[i] ?? 0;
            this.setTransform(x, animate);
            this.afterMove();
          }

          setTransform(x, animate = true) {
            if (animate === false) this.track.style.transition = "none";
            else this.track.style.transition = "";
            this.scrollX = x;
            this.track.style.transform = `translate3d(${-x}px, 0, 0)`;
          }

          afterMove() {
            const i = this.nearestPageIndex(this.scrollX);
            this.updateUI(i);
            this.announce();
            this.focusLeftmostSlide();
          }

          updateUI(pageIndex) {
            // Buttons enable/disable
            this.prevBtn.disabled = pageIndex === 0;
            this.nextBtn.disabled = pageIndex === this.pagePositions.length - 1;
            // Dots state
            Array.from(this.dotsWrap.children).forEach((b, idx) => {
              b.setAttribute("aria-current", String(idx === pageIndex));
            });
          }

          focusLeftmostSlide() {
            // Leftmost slide index ≈ how many full (slide + gap) widths we've scrolled
            const idx = Math.round(this.scrollX / (this.slideW + this.gap));
            const slide = this.slides[this.clampIndex(idx)];
            if (slide) slide.focus({ preventScroll: true });
          }

          clampIndex(i) {
            return Math.max(0, Math.min(this.slides.length - 1, i));
          }
          clamp(x, min, max) {
            return Math.max(min, Math.min(max, x));
          }

          nearestPageIndex(x) {
            let best = 0,
              bestDist = Infinity;
            for (let i = 0; i < this.pagePositions.length; i++) {
              const d = Math.abs(this.pagePositions[i] - x);
              if (d < bestDist) {
                best = i;
                bestDist = d;
              }
            }
            return best;
          }

          announce() {
            const page = this.nearestPageIndex(this.scrollX) + 1;
            const pages = this.pagePositions.length;
            // Leftmost (primary) slide index for announcement
            const leftIdx = Math.round(this.scrollX / (this.slideW + this.gap)) + 1;
            const totalSlides = this.slides.length;
            if (this.status) {
              this.status.textContent = `Page ${page} of ${pages}. Showing slide ${leftIdx} of ${totalSlides}.`;
            }
          }
        }

        // Init any .carousel on the page
        document.querySelectorAll(".carousel").forEach((el) => new NPlusHalfCarousel(el));
      })();
    </script>
  </body>
</html>
